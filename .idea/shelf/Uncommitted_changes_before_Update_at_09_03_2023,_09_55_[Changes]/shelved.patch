Index: BaseStation/interfaces/producer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\nimport json\n\nfrom kafka import KafkaProducer\n\n\n\nproducer = KafkaProducer(bootstrap_servers=['localhost:9092'], value_serializer=lambda x: json.dumps(x).encode('utf-8'))\n    \ndef send_sensor_msg(sensor_msg, sensor_type, flush = False):\n    sensor_stream = ''\n\n    match sensor_type:\n        case 'humidity sensor':\n            sensor_stream = 'humidity_stream'\n        case 'temperature sensor':\n            sensor_stream = 'temperature_stream'\n        case 'soil_moisture sensor':\n            sensor_stream = 'soil_moisture_stream'\n        case _:\n            print('Sensor message error, unassigned stream')\n\n    print('sending ', sensor_stream, sensor_msg)\n    producer.send(sensor_stream, sensor_msg)\n    if flush:\n        producer.flush()\n\ndef send_task_msg(task_msg, flush = False):\n    producer.send('task_stream', task_msg)\n    if flush:\n        producer.flush()\n\ndef send_rule_msg(rule_msg, flush = False):\n    producer.send('rule_stream', rule_msg)\n    if flush:\n        producer.flush()\n
===================================================================
diff --git a/BaseStation/interfaces/producer.py b/BaseStation/interfaces/producer.py
--- a/BaseStation/interfaces/producer.py	
+++ b/BaseStation/interfaces/producer.py	
@@ -10,15 +10,15 @@
 def send_sensor_msg(sensor_msg, sensor_type, flush = False):
     sensor_stream = ''
 
-    match sensor_type:
-        case 'humidity sensor':
-            sensor_stream = 'humidity_stream'
-        case 'temperature sensor':
-            sensor_stream = 'temperature_stream'
-        case 'soil_moisture sensor':
-            sensor_stream = 'soil_moisture_stream'
-        case _:
-            print('Sensor message error, unassigned stream')
+    # match sensor_type:
+    #     case 'humidity sensor':
+    #         sensor_stream = 'humidity_stream'
+    #     case 'temperature sensor':
+    #         sensor_stream = 'temperature_stream'
+    #     case 'soil_moisture sensor':
+    #         sensor_stream = 'soil_moisture_stream'
+    #     case _:
+    #         print('Sensor message error, unassigned stream')
 
     print('sending ', sensor_stream, sensor_msg)
     producer.send(sensor_stream, sensor_msg)
Index: BaseStation/Faust/rule_engine.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import operator\nfrom pathlib import Path\nimport json\n\nops = {\n    '<': operator.lt,\n    '<=': operator.le,\n    '=': operator.eq,\n    '>=': operator.ge,\n    '>': operator.gt,\n}\n\n\nclass Task:\n    \"\"\"Tasks for an actuator\n\n    Attributes:\n        target      The actuatorid/target to control\n        state       The intended on/off state of the instruction to the target\n        intensity   E.g., rotational speed of motor, pressure of sprinkler. Between 0 and 1.\n        duration    Optional duration until reversion to previous state in seconds. -1 for indefinite duration.\n    \"\"\"\n\n    def __init__(self, target: str, state: str, intensity: float, duration: int):\n        self.target = target\n        self.state = state\n        self.intensity = intensity\n        self.duration = duration\n    \n    def __str__(self):\n        return(f\"Task({self.target}, {self.state}, {self.intensity}, {self.duration})\")\n\nclass Condition:\n    def __init__(self, time: str, recurring: bool):\n        pass\n\n\n\nclass TimeCondition(Condition):\n    def __init__(self, time: str, recurring: bool):\n        self.time = time\n        self.recurring = recurring\n\nclass Rule:\n    def __init__(self, task: Task, condition: Condition):\n        self.task = task\n        self.condition = condition\n\n# conditionTime = datetime.datetime.now() + datetime.timedelta(seconds=10)\n\n# condition1 = Condition(conditionTime, False, 'test_sensor3', 20, '<')\n\nruleID = 0\n\nstored_rules = {}\n\nrelevant_sensors = {}\n\ndef analyse(sensor_message):\n    tasks = []\n    for ruleID in relevant_sensors[sensor_message.sensor_id]:\n        task = stored_rules[ruleID].task_message\n        condition = stored_rules[ruleID].condition_message\n        if ops[condition.relation](sensor_message.reading, condition.reading):\n            tasks.append(task)\n\n    return tasks\n    \n\n\nscript_location = Path(__file__).absolute().parent\n\n\ndef saveRule(rule_message):\n    try:\n        file_location = script_location / 'local_data/rules.txt'\n\n        with open(file_location, 'a', newline='', encoding='utf8') as f:\n\n            f.write(str(rule_message))\n\n    except Exception as e:\n        print(e)\n\ndef addRule(rule_message):\n    saveRule(rule_message)\n    global ruleID\n    stored_rules[ruleID] = rule_message\n    sensor_id = rule_message.condition_message.sensor_subject\n    if sensor_id in relevant_sensors: \n        relevant_sensors[sensor_id].add(ruleID)\n    else:\n        new_set = set()\n        new_set.add(ruleID)\n        relevant_sensors[sensor_id] = new_set\n    ruleID += 1
===================================================================
diff --git a/BaseStation/Faust/rule_engine.py b/BaseStation/Faust/rule_engine.py
--- a/BaseStation/Faust/rule_engine.py	
+++ b/BaseStation/Faust/rule_engine.py	
@@ -73,11 +73,12 @@
 
 def saveRule(rule_message):
     try:
-        file_location = script_location / 'local_data/rules.txt'
+        file_location = script_location / 'local_data/rules1.json'
 
         with open(file_location, 'a', newline='', encoding='utf8') as f:
-
-            f.write(str(rule_message))
+            print(1)
+            f.write(json.dumps({"hello":"nihao"}))
+            print(2)
 
     except Exception as e:
         print(e)
Index: BaseStation/Faust/base_station.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\n\nimport faust\nimport datetime\n\nimport config_supplier\nimport speed_processor as sp\nimport batch_processor as bp\nimport device_controller as dc\nimport rule_engine as re\n\n\n\nconfigurations = config_supplier.get_base_station_configs()\nMAX_BATCH_SIZE = int(configurations['max_batch_size'])\nHUMIDITY_BATCH_INTERVAL = int(configurations['humidity_interval'])\nTEMPERATURE_BATCH_INTERVAL = int(configurations['temperature_interval'])\nSOIL_MOISTURE_BATCH_INTERVAL = int(configurations['soil_moisture_interval'])\n\n\n\napp = faust.App(\n    'base_station',\n    broker='kafka://localhost:9092',\n    value_serializer='json',\n)\n\ndef get_timestamp():\n    return datetime.datetime.now()\n\nlatest_sensor_message = 'No messages'\nlatest_task_message = 'No messages'\n\nclass SensorMessage(faust.Record):\n    sensor_id: str\n    reading: float\n    sensor_type: str = ''\n    reading_unit: str = ''\n    timestamp: str = ''\n    latitude: float = ''\n    longitude: float = ''\n\nclass HumidityMessage(SensorMessage):\n    sensor_type: str = 'humidity sensor'\n\nclass TemperatureMessage(SensorMessage):\n    sensor_type: str = 'temperature sensor'\n\nclass SoilMoistureMessage(SensorMessage):\n    sensor_type: str = 'soil moisture sensor'\n\nclass TaskMessage(faust.Record):\n    actuator_target: str\n    state: bool\n    intensity: float\n    actuator_type: str = ''\n    duration: int = -1\n\n\n# class TimeConditionMessage(ConditionMessage):\n#     sensor_subject: str\n#     reading: float\n#     relation: str\n\nclass SensorConditionMessage(faust.Record):\n    sensor_subject: str\n    reading: float\n    relation: str\n\nclass RuleMessage(faust.Record):\n    task_message: TaskMessage\n    condition_message: SensorConditionMessage = None\n\n# defines humidity, temperature, soil moisture topics to receive sensor messages\nhumidity_stream = app.topic('humidity_stream', value_type=HumidityMessage)\ntemperature_stream = app.topic('temperature_stream', value_type=TemperatureMessage)\nsoil_moisture_stream = app.topic('soil_moisture_stream', value_type=SoilMoistureMessage)\n\nhumidity_batch = app.topic('humidity_batch', value_type=HumidityMessage)\ntemperature_batch = app.topic('temperature_batch', value_type=TemperatureMessage)\nsoil_moisture_batch = app.topic('soil_moisture_batch', value_type=SoilMoistureMessage)\n\ntask_stream = app.topic('task_stream', value_type=TaskMessage)\nrule_stream = app.topic('rule_stream', value_type=RuleMessage)\n\n# batch agents\n@app.agent(humidity_batch)\nasync def batch_agent_humidity(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=HUMIDITY_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n@app.agent(temperature_batch)\nasync def batch_agent_temperature(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=TEMPERATURE_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n@app.agent(soil_moisture_batch)\nasync def batch_agent_soil_moisture(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=SOIL_MOISTURE_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n\n\ndef fillSensorMessage(message):\n    message.timestamp = get_timestamp()\n    sensor_data = dc.getSensorData(message.sensor_id)\n    message.reading_unit = sensor_data.reading_unit\n    message.latitude = sensor_data.latitude\n    message.longitude = sensor_data.longitude\n\n    global latest_sensor_message\n    latest_sensor_message = message\n    return message\n\ndef fillTaskMessage(message):\n    message.timestamp = get_timestamp()\n    actuator_data = dc.getActuatorData(message.actuator_target)\n    message.actuator_type = actuator_data.device_type\n\n    global latest_task_message\n    latest_task_message = message\n    return message\n\ndef jsonMessage(message):\n    return {\n        \"sensor_id\" : message.sensor_id,\n        \"sensor_type\" : message.sensor_type,\n        \"data\" : message.reading,\n        \"unit\" : message.reading_unit,\n        \"longitude\" : message.longitude,\n        \"latitude\" : message.latitude,\n        \"timestamp\" : time.time_ns(), # This is just temporary used\n    }\n# streaming agents\n@app.agent(humidity_stream, sink=[humidity_batch])\nasync def stream_agent_humidity(messages):\n    async for message in messages:\n        print(message)\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\n@app.agent(temperature_stream, sink=[temperature_batch])\nasync def stream_agent_temperature(messages):\n    async for message in messages:\n        print(message)\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\n@app.agent(soil_moisture_stream, sink=[soil_moisture_batch])\nasync def stream_agent_soil_moisture(messages):\n    async for message in messages:\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\nrules_table = app.Table('rules', default=RuleMessage)\n\n# tasks agent\n@app.agent(task_stream)\nasync def tasks_agent(messages):\n    async for message in messages:\n        print('received')\n        message = fillTaskMessage(message)\n        newState = 'ON' if message.state else 'OFF'\n        print('Task Dispatched: ' + 'Actuator ' + message.actuator_target + ' of type ' \n              + message.actuator_type + ' to be turned ' + newState + ' at ' + str(message.intensity) \n              + ' intensity for ' + str(message.duration) + ' seconds ')\n\n\n# rules agent\n@app.agent(rule_stream)\nasync def rules_agent(messages):\n    async for message in messages:\n        if message.condition_message == None:\n            await task_stream.send(value=(message.task_message))\n        else:\n            re.addRule(message)\n\n\n@app.page('/sensor-messages/')\nasync def update_sensor_message(self, request):\n    global latest_sensor_message\n    return self.json(latest_sensor_message)\n\n@app.page('/task-messages/')\nasync def update_task_message(self, request):\n    global latest_task_message\n    return self.json(latest_task_message)\n\n\n\nif __name__ == '__main__':\n    app.main()\n
===================================================================
diff --git a/BaseStation/Faust/base_station.py b/BaseStation/Faust/base_station.py
--- a/BaseStation/Faust/base_station.py	
+++ b/BaseStation/Faust/base_station.py	
@@ -138,7 +138,7 @@
         print(message)
         message = fillSensorMessage(message)
         await sp.process(message)
-        #await sp.sendToHub(jsonMessage(message))
+        await sp.sendToHub(jsonMessage(message))
         yield message
 
 @app.agent(temperature_stream, sink=[temperature_batch])
Index: BaseStation/interfaces/actuator_interface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\nimport time\nimport producer as ps\nimport websockets\nimport json\n\nclients = dict()\nmessage_buffer = []\ncheck = False\n\nasync def handle_message(websocket, path):\n    while True:\n        json_message = await websocket.recv()\n        check = False\n        data = json.loads(json_message)\n        if data[\"actuatorId\"] not in clients:\n            clients[data[\"actuatorId\"]] = websocket\n        #     shared_dict.set_shared_value(data[\"actuatorId\"],websocket)\n        # print(shared_dict.shared_dict)\n        print(json_message)\n        # print(clients)\n        # time.sleep(2)\n        # command = \"on\"\n        # # print(f\"Received message: {message}\")\n        # data = {\"instruction\" : command}\n        # await websocket.send(json.dumps(data))\n\nasync def sendCommand(actuatorId, command):\n    print(clients)\n    if actuatorId not in clients:\n        print(\"No such actuator\")\n        return\n    websocket = clients[actuatorId]\n    print(websocket)\n    data = json.dumps({\"instruction\":command})\n    await websocket.send(data)\n    check = True\n\nif __name__ == '__main__':\n    start_server = websockets.serve(handle_message, \"0.0.0.0\", 8765)\n    # start_server = websockets.serve(server.handle_message, \"localhost\", 8765)\n\n    asyncio.get_event_loop().run_until_complete(start_server)\n    asyncio.get_event_loop().run_forever()\n\n
===================================================================
diff --git a/BaseStation/interfaces/actuator_interface.py b/BaseStation/interfaces/actuator_interface.py
--- a/BaseStation/interfaces/actuator_interface.py	
+++ b/BaseStation/interfaces/actuator_interface.py	
@@ -1,8 +1,9 @@
 import asyncio
-import time
-import producer as ps
+import threading
+
 import websockets
 import json
+from aiohttp import web
 
 clients = dict()
 message_buffer = []
@@ -36,10 +37,35 @@
     await websocket.send(data)
     check = True
 
-if __name__ == '__main__':
+async def actuatorServer():
     start_server = websockets.serve(handle_message, "0.0.0.0", 8765)
     # start_server = websockets.serve(server.handle_message, "localhost", 8765)
-
     asyncio.get_event_loop().run_until_complete(start_server)
     asyncio.get_event_loop().run_forever()
 
+
+async def handle_request(request):
+    if request.method == 'POST':
+        data = await request.text()
+        print(data)
+        response = web.Response(text="Received data: {}".format(data))
+    else:
+        response = web.Response(status=405)
+    return response
+
+async def receiveCommandServer():
+    app = web.Application()
+    app.add_routes([web.post('/receiveCommand', handle_request)])
+    PORT = 23333
+    web.run_app(app, port=PORT)
+
+async def main():
+    await asyncio.gather(actuatorServer(), receiveCommandServer())
+    # t1 = threading.Thread(target=actuatorServer)
+    # t2 = threading.Thread(target=receiveCommandServer)
+    # t1.start()
+    # t2.start()
+
+if __name__ == '__main__':
+    asyncio.run(main())
+
Index: BaseStation/Faust/speed_processor.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import aiohttp\n\nimport base_station as bs\nimport rule_engine as re\nimport device_controller as dc\n\n\n\n# send to rule engine and retrieve applicable tasks\nasync def process(message):\n    tasks = re.analyse(message)\n    for task in tasks:\n        actuator_data = dc.getActuatorData(task.actuator_target)\n        task_msg = bs.TaskMessage(task.actuator_target, actuator_data.device_type, task.state, task.intensity, task.duration)\n\n        await bs.task_stream.send(value=task_msg)\n\n\n\n# forward to main hub\nasync def sendToHub(message):\n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post('http://localhost:5555/sensor_data', json=message) as resp:\n                print(\"Response Status: {}\".format(resp.status))\n    except aiohttp.ClientConnectorError as e:\n        print(f\"connection is not available: {e}\")
===================================================================
diff --git a/BaseStation/Faust/speed_processor.py b/BaseStation/Faust/speed_processor.py
--- a/BaseStation/Faust/speed_processor.py	
+++ b/BaseStation/Faust/speed_processor.py	
@@ -21,7 +21,7 @@
 async def sendToHub(message):
     try:
         async with aiohttp.ClientSession() as session:
-            async with session.post('http://localhost:5555/sensor_data', json=message) as resp:
+            async with session.post('http://192.168.137.19:5555/sensor_data', json=message) as resp:
                 print("Response Status: {}".format(resp.status))
     except aiohttp.ClientConnectorError as e:
         print(f"connection is not available: {e}")
\ No newline at end of file
diff --git a/BaseStation/interfaces/test_rule.py b/BaseStation/interfaces/trule.py
rename from BaseStation/interfaces/test_rule.py
rename to BaseStation/interfaces/trule.py
