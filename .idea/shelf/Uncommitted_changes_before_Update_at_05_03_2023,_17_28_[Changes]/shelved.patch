Index: BaseStation/interfaces/actuator_interface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\nimport time\nimport producer as ps\nimport websockets\nimport json\n\nclients = dict()\nmessage_buffer = []\ncheck = False\n\nasync def handle_message(websocket, path):\n    while True:\n        json_message = await websocket.recv()\n        check = False\n        data = json.loads(json_message)\n        if data[\"actuatorId\"] not in clients:\n            clients[data[\"actuatorId\"]] = websocket\n        #     shared_dict.set_shared_value(data[\"actuatorId\"],websocket)\n        # print(shared_dict.shared_dict)\n        print(json_message)\n        # print(clients)\n        # time.sleep(2)\n        # command = \"on\"\n        # # print(f\"Received message: {message}\")\n        # data = {\"instruction\" : command}\n        # await websocket.send(json.dumps(data))\n\nasync def sendCommand(actuatorId, command):\n    print(clients)\n    if actuatorId not in clients:\n        print(\"No such actuator\")\n        return\n    websocket = clients[actuatorId]\n    print(websocket)\n    data = json.dumps({\"instruction\":command})\n    await websocket.send(data)\n    check = True\n\nif __name__ == '__main__':\n    start_server = websockets.serve(handle_message, \"0.0.0.0\", 8765)\n    # start_server = websockets.serve(server.handle_message, \"localhost\", 8765)\n\n    asyncio.get_event_loop().run_until_complete(start_server)\n    asyncio.get_event_loop().run_forever()\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BaseStation/interfaces/actuator_interface.py b/BaseStation/interfaces/actuator_interface.py
--- a/BaseStation/interfaces/actuator_interface.py	(revision e68b56cf048d8e0666ddf3b9921b77b649deba71)
+++ b/BaseStation/interfaces/actuator_interface.py	(date 1677843574362)
@@ -1,8 +1,9 @@
 import asyncio
-import time
-import producer as ps
+import threading
+
 import websockets
 import json
+from aiohttp import web
 
 clients = dict()
 message_buffer = []
@@ -36,10 +37,35 @@
     await websocket.send(data)
     check = True
 
-if __name__ == '__main__':
+async def actuatorServer():
     start_server = websockets.serve(handle_message, "0.0.0.0", 8765)
     # start_server = websockets.serve(server.handle_message, "localhost", 8765)
-
     asyncio.get_event_loop().run_until_complete(start_server)
     asyncio.get_event_loop().run_forever()
 
+
+async def handle_request(request):
+    if request.method == 'POST':
+        data = await request.text()
+        print(data)
+        response = web.Response(text="Received data: {}".format(data))
+    else:
+        response = web.Response(status=405)
+    return response
+
+async def receiveCommandServer():
+    app = web.Application()
+    app.add_routes([web.post('/receiveCommand', handle_request)])
+    PORT = 23333
+    web.run_app(app, port=PORT)
+
+async def main():
+    await asyncio.gather(actuatorServer(), receiveCommandServer())
+    # t1 = threading.Thread(target=actuatorServer)
+    # t2 = threading.Thread(target=receiveCommandServer)
+    # t1.start()
+    # t2.start()
+
+if __name__ == '__main__':
+    asyncio.run(main())
+
Index: BaseStation/interfaces/producer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\nimport json\n\nfrom kafka import KafkaProducer\n\n\n\nproducer = KafkaProducer(bootstrap_servers=['localhost:9092'], value_serializer=lambda x: json.dumps(x).encode('utf-8'))\n    \ndef send_sensor_msg(sensor_msg, sensor_type, flush = False):\n    sensor_stream = ''\n\n    match sensor_type:\n        case 'humidity sensor':\n            sensor_stream = 'humidity_stream'\n        case 'temperature sensor':\n            sensor_stream = 'temperature_stream'\n        case 'soil_moisture sensor':\n            sensor_stream = 'soil_moisture_stream'\n        case _:\n            print('Sensor message error, unassigned stream')\n\n    print('sending ', sensor_stream, sensor_msg)\n    producer.send(sensor_stream, sensor_msg)\n    if flush:\n        producer.flush()\n\ndef send_task_msg(task_msg, flush = False):\n    producer.send('task_stream', task_msg)\n    if flush:\n        producer.flush()\n\n\n\nhumidity_msg = {'sensor_id':'test_sensor1', 'reading':60}\ntemperature_msg = {'sensor_id':'test_sensor2', 'reading':20}\nsoil_moisture_msg = {'sensor_id':'test_sensor3', 'reading':10}\n\n#send_humidity_msg(humidity_msg, True)\n#send_temperature_msg(temperature_msg, True)\n#send_soil_moisture_msg(soil_moisture_msg, True)\n\ntask_msg = {'actuator_target':'test_actuator1', 'state':True, 'intensity':0.5, 'duration':10}\n\nsend_task_msg(task_msg, True)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BaseStation/interfaces/producer.py b/BaseStation/interfaces/producer.py
--- a/BaseStation/interfaces/producer.py	(revision e68b56cf048d8e0666ddf3b9921b77b649deba71)
+++ b/BaseStation/interfaces/producer.py	(date 1678031145381)
@@ -10,15 +10,15 @@
 def send_sensor_msg(sensor_msg, sensor_type, flush = False):
     sensor_stream = ''
 
-    match sensor_type:
-        case 'humidity sensor':
-            sensor_stream = 'humidity_stream'
-        case 'temperature sensor':
-            sensor_stream = 'temperature_stream'
-        case 'soil_moisture sensor':
-            sensor_stream = 'soil_moisture_stream'
-        case _:
-            print('Sensor message error, unassigned stream')
+    # match sensor_type:
+    #     case 'humidity sensor':
+    #         sensor_stream = 'humidity_stream'
+    #     case 'temperature sensor':
+    #         sensor_stream = 'temperature_stream'
+    #     case 'soil_moisture sensor':
+    #         sensor_stream = 'soil_moisture_stream'
+    #     case _:
+    #         print('Sensor message error, unassigned stream')
 
     print('sending ', sensor_stream, sensor_msg)
     producer.send(sensor_stream, sensor_msg)
Index: BaseStation/Faust/base_station.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\n\nimport faust\nimport datetime\n\nimport config_supplier\nimport speed_processor as sp\nimport batch_processor as bp\nimport device_controller as dc\n\n\n\nconfigurations = config_supplier.get_base_station_configs()\nMAX_BATCH_SIZE = int(configurations['max_batch_size'])\nHUMIDITY_BATCH_INTERVAL = int(configurations['humidity_interval'])\nTEMPERATURE_BATCH_INTERVAL = int(configurations['temperature_interval'])\nSOIL_MOISTURE_BATCH_INTERVAL = int(configurations['soil_moisture_interval'])\n\n\n\napp = faust.App(\n    'base_station',\n    broker='kafka://localhost:9092',\n    value_serializer='json',\n)\n\ndef get_timestamp():\n    return datetime.datetime.now()\n\nlatest_sensor_message = 'No messages'\nlatest_task_message = 'No messages'\n\nclass SensorMessage(faust.Record):\n    sensor_id: str\n    reading: str\n    sensor_type: str = ''\n    reading_unit: str = ''\n    timestamp: str = ''\n    latitude: float = ''\n    longitude: float = ''\n\nclass HumidityMessage(SensorMessage):\n    sensor_type: str = 'humidity sensor'\n\nclass TemperatureMessage(SensorMessage):\n    sensor_type: str = 'temperature sensor'\n\nclass SoilMoistureMessage(SensorMessage):\n    sensor_type: str = 'soil moisture sensor'\n\nclass TaskMessage(faust.Record):\n    actuator_target: str\n    state: bool\n    intensity: float\n    actuator_type: str = ''\n    duration: int = -1\n    timestamp: str = ''\n\n# defines humidity, temperature, soil moisture topics to receive sensor messages\nhumidity_stream = app.topic('humidity_stream', value_type=HumidityMessage)\ntemperature_stream = app.topic('temperature_stream', value_type=TemperatureMessage)\nsoil_moisture_stream = app.topic('soil_moisture_stream', value_type=SoilMoistureMessage)\n\nhumidity_batch = app.topic('humidity_batch', value_type=HumidityMessage)\ntemperature_batch = app.topic('temperature_batch', value_type=TemperatureMessage)\nsoil_moisture_batch = app.topic('soil_moisture_batch', value_type=SoilMoistureMessage)\n\ntask_stream = app.topic('task_stream', value_type=TaskMessage)\n\n# batch agents\n@app.agent(humidity_batch)\nasync def batch_agent_humidity(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=HUMIDITY_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n@app.agent(temperature_batch)\nasync def batch_agent_temperature(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=TEMPERATURE_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n@app.agent(soil_moisture_batch)\nasync def batch_agent_soil_moisture(batches):\n    async for batch in batches.take(MAX_BATCH_SIZE, within=SOIL_MOISTURE_BATCH_INTERVAL):\n        bp.store_locally(batch)\n\n\n\ndef fillSensorMessage(message):\n    message.timestamp = get_timestamp()\n    sensor_data = dc.getSensorData(message.sensor_id)\n    message.reading_unit = sensor_data.reading_unit\n    message.latitude = sensor_data.latitude\n    message.longitude = sensor_data.longitude\n\n    global latest_sensor_message\n    latest_sensor_message = message\n    return message\n\ndef fillTaskMessage(message):\n    message.timestamp = get_timestamp()\n    actuator_data = dc.getActuatorData(message.actuator_target)\n    message.actuator_type = actuator_data.device_type\n\n    global latest_task_message\n    latest_task_message = message\n    return message\n\ndef jsonMessage(message):\n    return {\n        \"sensor_id\" : message.sensor_id,\n        \"sensor_type\" : message.sensor_type,\n        \"data\" : message.reading,\n        \"unit\" : message.reading_unit,\n        \"longitude\" : message.longitude,\n        \"latitude\" : message.latitude,\n        \"timestamp\" : time.time_ns(), # This is just temporary used\n    }\n# streaming agents\n@app.agent(humidity_stream, sink=[humidity_batch])\nasync def stream_agent_humidity(messages):\n    async for message in messages:\n        print(message)\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\n@app.agent(temperature_stream, sink=[temperature_batch])\nasync def stream_agent_temperature(messages):\n    async for message in messages:\n        print(message)\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\n@app.agent(soil_moisture_stream, sink=[soil_moisture_batch])\nasync def stream_agent_soil_moisture(messages):\n    async for message in messages:\n        message = fillSensorMessage(message)\n        await sp.process(message)\n        #await sp.sendToHub(jsonMessage(message))\n        yield message\n\n\n\n# tasks agent\n@app.agent(task_stream)\nasync def tasks_agent(messages):\n    async for message in messages:\n        message = fillTaskMessage(message)\n        newState = 'ON' if message.state else 'OFF'\n        print('Task Dispatched: ' + 'Actuator ' + message.actuator_target + ' of type ' \n              + message.actuator_type + ' to be turned ' + newState + ' at ' + str(message.intensity) \n              + ' intensity for ' + str(message.duration) + ' seconds ')\n\n\n\n@app.page('/sensor-messages/')\nasync def update_sensor_message(self, request):\n    global latest_sensor_message\n    return self.json(latest_sensor_message)\n\n@app.page('/task-messages/')\nasync def update_task_message(self, request):\n    global latest_task_message\n    return self.json(latest_task_message)\n\n\n\nif __name__ == '__main__':\n    app.main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BaseStation/Faust/base_station.py b/BaseStation/Faust/base_station.py
--- a/BaseStation/Faust/base_station.py	(revision e68b56cf048d8e0666ddf3b9921b77b649deba71)
+++ b/BaseStation/Faust/base_station.py	(date 1677845576537)
@@ -122,7 +122,7 @@
         print(message)
         message = fillSensorMessage(message)
         await sp.process(message)
-        #await sp.sendToHub(jsonMessage(message))
+        await sp.sendToHub(jsonMessage(message))
         yield message
 
 @app.agent(temperature_stream, sink=[temperature_batch])
Index: BaseStation/Faust/speed_processor.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import aiohttp\n\nimport base_station as bs\nimport rule_engine as re\nimport device_controller as dc\n\n\n\n# send to rule engine and retrieve applicable tasks\nasync def process(message):\n    tasks = re.analyse(message)\n    for task in tasks:\n        actuator_data = dc.getActuatorData(task.target)\n        task_msg = bs.TaskMessage(task.target, actuator_data.device_type, task.state, task.intensity, task.duration)\n\n        await bs.task_stream.send(value=task_msg)\n\n\n\n# forward to main hub\nasync def sendToHub(message):\n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post('http://localhost:5555/sensor_data', json=message) as resp:\n                print(\"Response Status: {}\".format(resp.status))\n    except aiohttp.ClientConnectorError as e:\n        print(f\"connection is not available: {e}\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BaseStation/Faust/speed_processor.py b/BaseStation/Faust/speed_processor.py
--- a/BaseStation/Faust/speed_processor.py	(revision e68b56cf048d8e0666ddf3b9921b77b649deba71)
+++ b/BaseStation/Faust/speed_processor.py	(date 1677848209475)
@@ -21,7 +21,7 @@
 async def sendToHub(message):
     try:
         async with aiohttp.ClientSession() as session:
-            async with session.post('http://localhost:5555/sensor_data', json=message) as resp:
+            async with session.post('http://192.168.137.19:5555/sensor_data', json=message) as resp:
                 print("Response Status: {}".format(resp.status))
     except aiohttp.ClientConnectorError as e:
         print(f"connection is not available: {e}")
\ No newline at end of file
